/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export class totowActor extends Actor {
	/** @override */
	prepareData() {
		// Prepare data for the actor. Calling the super version of this executes
		// the following, in order: data reset (to clear active effects),
		// prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
		// prepareDerivedData().
		super.prepareData();
	}

	/** @override */
	prepareBaseData() {
		// Data modifications in this step occur before processing embedded
		// documents or derived data.
	}

	/**
	 * @override
	 * Augment the actor source data with additional dynamic data that isn't
	 * handled by the actor's DataModel. Data calculated in this step should be
	 * available both inside and outside of character sheets (such as if an actor
	 * is queried and has a roll executed directly from it).
	 */
	prepareDerivedData() {
		const actorData = this;
		const flags = actorData.flags.talesoftheoldwest || {};
	}

	/**
	 *
	 * @override
	 * Augment the actor's default getRollData() method by appending the data object
	 * generated by the its DataModel's getRollData(), or null. This polymorphic
	 * approach is useful when you have actors & items that share a parent Document,
	 * but have slightly different data preparation needs.
	 */
	getRollData() {
		return { ...super.getRollData(), ...(this.system.getRollData?.() ?? null) };
	}
	// *************************************************
	// Setupthe prototype token
	// *************************************************
	async _preCreate(data, options, user) {
		await super._preCreate(data, options, user);
		let tokenProto = {
			'prototypeToken.displayName': CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,
			'prototypeToken.displayBars': CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,
			'prototypeToken.disposition': CONST.TOKEN_DISPOSITIONS.FRIENDLY,
			'prototypeToken.name': `${data.name}`,
			'prototypeToken.bar1': { attribute: 'header.health' },
			'prototypeToken.bar2': { attribute: 'None' },
			// 'prototypeToken.vision': true,
			'prototypeToken.actorLink': true,
			'prototypeToken.sight.enabled': 'true',
			'prototypeToken.sight.range': '12',
		};
		// if (game.settings.get('alienrpg', 'defaultTokenSettings')) {
		switch (data.type) {
			case 'pc':
				tokenProto['prototypeToken.bar2'] = { attribute: 'header.stress' };
				break;
			case 'npc':
				tokenProto['prototypeToken.actorLink'] = false;
				tokenProto['prototypeToken.disposition'] = CONST.TOKEN_DISPOSITIONS.HOSTILE;
				tokenProto['prototypeToken.sight.enabled'] = false;
				break;
		}
		// }

		this.updateSource(tokenProto);
		// this.updateSource(createData);
	}

	async addCondition(effect) {
		if (typeof effect === 'string') effect = foundry.utils.duplicate(CONFIG.TALESOFTHEOLDWEST.conditionEffects.find((e) => e.id == effect));
		if (!effect) return 'No Effect Found';
		if (!effect.id) return 'Conditions require an id field';

		let existing = await this.hasCondition(effect.id);
		if (!existing) {
			effect.label = game.i18n.localize(effect.label).replace(/(^\w{1})|(\s+\w{1})/g, (letter) => letter.toUpperCase());
			effect.name = game.i18n.localize(effect.name).replace(/(^\w{1})|(\s+\w{1})/g, (letter) => letter.toUpperCase());
			let field = `system.conditions.${effect.name}`;
			effect['statuses'] = effect.id;
			delete effect.id;
			return await this.createEmbeddedDocuments('ActiveEffect', [effect]);
		}
	}

	async removeCondition(effect) {
		if (typeof effect === 'string') effect = foundry.utils.duplicate(CONFIG.TALESOFTHEOLDWEST.conditionEffects.find((e) => e.id == effect));
		if (!effect) return 'No Effect Found';
		if (!effect.id) return 'Conditions require an id field';
		let existing = await this.hasCondition(effect.id);
		if (existing) {
			return await this.deleteEmbeddedDocuments('ActiveEffect', [existing._id]);
		}
	}
	async hasCondition(conditionKey) {
		let existing = '';
		existing = this.effects.find((effect) => effect.statuses.has(conditionKey));
		return existing;
	}
}
