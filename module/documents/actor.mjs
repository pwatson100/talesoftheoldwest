import { rollAttrib } from '../helpers/diceroll.mjs';

/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export class totowActor extends Actor {
	/** @override */
	prepareData() {
		// Prepare data for the actor. Calling the super version of this executes
		// the following, in order: data reset (to clear active effects),
		// prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
		// prepareDerivedData().
		super.prepareData();
	}

	/** @override */
	prepareBaseData() {
		// Data modifications in this step occur before processing embedded
		// documents or derived data.
	}

	/**
	 * @override
	 * Augment the actor source data with additional dynamic data that isn't
	 * handled by the actor's DataModel. Data calculated in this step should be
	 * available both inside and outside of character sheets (such as if an actor
	 * is queried and has a roll executed directly from it).
	 */
	prepareDerivedData() {
		const actorData = this;
		const flags = actorData.flags.talesoftheoldwest || {};
	}

	/**
	 *
	 * @override
	 * Augment the actor's default getRollData() method by appending the data object
	 * generated by the its DataModel's getRollData(), or null. This polymorphic
	 * approach is useful when you have actors & items that share a parent Document,
	 * but have slightly different data preparation needs.
	 */
	getRollData() {
		return { ...super.getRollData(), ...(this.system.getRollData?.() ?? null) };
	}
	// *************************************************
	// Setupthe prototype token
	// *************************************************
	async _preCreate(data, options, user) {
		await super._preCreate(data, options, user);
		let tokenProto = {
			'prototypeToken.displayName': CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,
			'prototypeToken.displayBars': CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,
			'prototypeToken.disposition': CONST.TOKEN_DISPOSITIONS.FRIENDLY,
			'prototypeToken.name': `${data.name}`,
			'prototypeToken.bar1': { attribute: 'header.health' },
			'prototypeToken.bar2': { attribute: 'None' },
			// 'prototypeToken.vision': true,
			'prototypeToken.actorLink': true,
			'prototypeToken.sight.enabled': 'true',
			'prototypeToken.sight.range': '12',
		};
		// if (game.settings.get('alienrpg', 'defaultTokenSettings')) {
		switch (data.type) {
			case 'pc':
				tokenProto['prototypeToken.bar2'] = { attribute: 'header.stress' };
				break;
			case 'npc':
				tokenProto['prototypeToken.actorLink'] = false;
				tokenProto['prototypeToken.disposition'] = CONST.TOKEN_DISPOSITIONS.HOSTILE;
				tokenProto['prototypeToken.sight.enabled'] = false;
				break;
		}
		// }

		this.updateSource(tokenProto);
		// this.updateSource(createData);
	}

	async addCondition(effect) {
		if (typeof effect === 'string') effect = foundry.utils.duplicate(CONFIG.TALESOFTHEOLDWEST.conditionEffects.find((e) => e.id == effect));
		if (!effect) return 'No Effect Found';
		if (!effect.id) return 'Conditions require an id field';

		let existing = await this.hasCondition(effect.id);
		if (!existing) {
			effect.label = game.i18n.localize(effect.label).replace(/(^\w{1})|(\s+\w{1})/g, (letter) => letter.toUpperCase());
			effect.name = game.i18n.localize(effect.name).replace(/(^\w{1})|(\s+\w{1})/g, (letter) => letter.toUpperCase());
			effect['statuses'] = effect.id;
			delete effect.id;
			return await this.createEmbeddedDocuments('ActiveEffect', [effect]);
		}
	}

	async removeCondition(effect) {
		if (typeof effect === 'string') effect = foundry.utils.duplicate(CONFIG.TALESOFTHEOLDWEST.conditionEffects.find((e) => e.id == effect));
		if (!effect) return 'No Effect Found';
		if (!effect.id) return 'Conditions require an id field';
		let existing = await this.hasCondition(effect.id);
		if (existing) {
			return await this.deleteEmbeddedDocuments('ActiveEffect', [existing._id]);
		}
	}
	async hasCondition(conditionKey) {
		let existing = '';
		existing = this.effects.find((effect) => effect.statuses.has(conditionKey));
		return existing;
	}

	async rollCrit(actor, type, dataset, manCrit) {
		let cFatal = false;
		let fatal = [];
		let rollFatal = '';
		let newFatalTime = '';
		let atable = '';
		let testArray = '';
		let rollheal = '';
		let newHealTime = '';
		let htmlData = '';
		let resultImage = '';
		let diceRoll = '';
		let update = {};
		let noMods = '';

		switch (type) {
			case 'pc':
			case 'npc':
				atable = game.tables.getName(game.i18n.localize('ALIENRPG.CriticalInjuries')) || game.tables.getName('Critical Injuries');
				if (atable === null || atable === undefined) {
					ui.notifications.warn(game.i18n.localize('ALIENRPG.NoCharCrit'));
					return;
				}

				break;
			default:
				return;
		}

		if (!manCrit) {
			diceRoll = await atable.draw({ displayChat: false });
		} else {
			const formula = manCrit;
			const roll = await new Roll(formula).evaluate();
			diceRoll = await atable.draw({ roll: roll, displayChat: false });
		}
		const messG = diceRoll.results[0].text;
		switch (type) {
			case 'pc':
			case 'npc':
				{
					resultImage = diceRoll.results[0].img;
					// Split out the components
					testArray = messG
						.replace(/(<p>)|(<strong>)|(<\/strong>)/gi, '')
						.replace(/(<\/p>)/gi, ': ')
						.split(/[:] /gi);

					// Process Fatial
					fatal = testArray[5].split(/[\/] /gi);
					if (fatal[0] != game.i18n.localize('TALESOFTHEOLDWEST.General.no')) {
						if (fatal[1] === game.i18n.localize('TALESOFTHEOLDWEST.Criticals.instant')) {
							cFatal = true;
							fatal[0] =
								'<strong style="color: red;">' + fatal[0].toUpperCase() + '</strong><br>' + game.i18n.localize('TALESOFTHEOLDWEST.Criticals.endOfTheTrail');
							testArray[11] = '<strong style="color: red;">' + testArray[11] + '</strong>';
						} else {
							rollFatal = fatal[1].match(/^\[\[([0-9]d[0-9]+)]/)[1];
							newFatalTime = fatal[1].match(/^\[\[([0-9]d[0-9]+)\]\] ?(.*)/)[2];
							fatal[1] = (await new Roll(`${rollFatal}`).evaluate()).result + ' ' + newFatalTime;
							fatal[0] = fatal[0].toUpperCase();

							switch (testArray[5]) {
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' ':
									{
										cFatal = true;
										fatal[0] = '<strong style="color: red;">' + game.i18n.localize('TALESOFTHEOLDWEST.General.yes').toUpperCase() + '</strong>';
									}
									break;
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' −1 / [[1d6]] Rounds':
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' −1 / [[2d6]] Rounds':
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' −1 / [[1d6]] Turns':
									{
										cFatal = true;
										fatal[0] =
											'<strong style="color: red;">' +
											game.i18n.localize('TALESOFTHEOLDWEST.General.yes').toUpperCase() +
											'</strong><br>' +
											game.i18n.localize('TALESOFTHEOLDWEST.Criticals.rollResilience') +
											fatal[1] +
											'<br> -1 to <strong>' +
											game.i18n.localize('TALESOFTHEOLDWEST.Ability.Doctorin.long') +
											'</strong> roll.';
									}
									break;
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' / [[1d6]] Turns':
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' / [[2d6]] Turns':
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' / [[1d6]] Days':
									{
										cFatal = true;
										fatal[0] =
											'<strong style="color: red;">' +
											game.i18n.localize('TALESOFTHEOLDWEST.General.yes').toUpperCase() +
											'</strong><br>' +
											game.i18n.localize('TALESOFTHEOLDWEST.Criticals.rollResilience') +
											fatal[1];
									}
									break;
								default:
									cFatal = false;
									break;
							}
						}
					} else {
						fatal[0] = game.i18n.localize('TALESOFTHEOLDWEST.General.no');
					}

					// Process Healing Time
					if ((testArray[7].length > 0) & (fatal[1] != 'Instant')) {
						rollheal = testArray[7].match(/^\[\[([0-9]d[0-9]+)]/)[1];
						newHealTime = testArray[7].match(/^\[\[([0-9]d[0-9]+)\]\] ?(.*)/)[2];
						testArray[7] = (await new Roll(`${rollheal}`).evaluate()).result + ' ' + newHealTime;
					} else {
						testArray[7] = game.i18n.localize('TALESOFTHEOLDWEST.ItemModifierSelect.none');
					}

					// Setup Modifiers
					switch (diceRoll.roll._total) {
						case 11:
						case 14:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Move.listName'),
								value: '-1',
								state: 'Active',
							};
							update[`system.itemModifiers.[1]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Fightin.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 12:
						case 21:
						case 23:
						case 41:
						case 51:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Move.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 22:
						case 44:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Resilience.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 31:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Shootin.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 32:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Shootin.listName'),
								value: '-1',
								state: 'Active',
							};
							update[`system.itemModifiers.[1]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Fightin.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 52:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Move.listName'),
								value: '-2',
								state: 'Active',
							};
							break;
						case 61:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Performin.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 62:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Labor.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 63:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Shootin.listName'),
								value: '-2',
								state: 'Active',
							};
							update[`system.itemModifiers.[1]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Hawkeye.listName'),
								value: '-2',
								state: 'Active',
							};
							break;
						default:
							noMods = true;
							break;
					}

					//
					// Now create the item on the sheet
					//

					let rollData = {
						type: 'crit',
						img: resultImage,
						name: `#${diceRoll.roll._total} ${testArray[1]} - ${testArray[3]}`,
						'system.location': testArray[1].toLowerCase().replace(/\s/g, ''),
						'system.injury': testArray[3],
						'system.healingtime': testArray[7],
						'system.fatal': cFatal,
						'system.fatalmessage': fatal[0].replace(/(YES)\s/g, ''),
						'system.imediateeffect': testArray[9],
						'system.longtermeffect': testArray[11],
					};

					const theItem = await this.createEmbeddedDocuments('Item', [rollData]);

					//
					// Now add the Modifiers if there are any
					//
					if (!noMods) {
						await theItem[0].update(update);
					}

					//)
					// Prepare the data for the chat message
					//

					htmlData = {
						actorname: actor.name,
						img: resultImage,
						name: `#${diceRoll.roll._total} ${testArray[1]}`,
						injury: testArray[3],
						fatal: fatal[0],
						healingtime: testArray[7],
						imediateeffect: testArray[9],
						longtermeffect: testArray[11],
						manCrit: manCrit,
					};
				}
				break;
		}

		// Now push the correct chat message

		const html = await renderTemplate(`systems/talesoftheoldwest/templates/chat/crit-roll-${actor.type}.hbs`, htmlData);

		let chatData = {
			user: game.user.id,
			speaker: {
				actor: actor.id,
			},
			content: html,
			other: game.users.contents.filter((u) => u.isGM).map((u) => u.id),
			sound: CONFIG.sounds.dice,
		};

		// Apply the Active Effect

		switch (type) {
			case 'pc':
			case 'npc':
				await this.addCondition('criticalinj');
				break;
			// case 'creature':criticalinj
			// 	console.log("it's a Creature Crit");
			// 	break;

			default:
				break;
		}

		ChatMessage.applyRollMode(chatData, game.settings.get('core', 'rollMode'));
		return ChatMessage.create(chatData);
	}

	async rollCritMan(actor, type, dataset) {
		function myRenderTemplate(template) {
			let confirmed = false;
			renderTemplate(template).then((dlg) => {
				new Dialog({
					title: game.i18n.localize('TALESOFTHEOLDWEST.dialog.RollManCrit'),
					content: dlg,
					buttons: {
						one: {
							icon: '<i class="fas fa-check"></i>',
							label: game.i18n.localize('TALESOFTHEOLDWEST.dialog.roll'),
							callback: () => (confirmed = true),
						},
						four: {
							icon: '<i class="fas fa-times"></i>',
							label: game.i18n.localize('TALESOFTHEOLDWEST.dialog.cancel'),
							callback: () => (confirmed = false),
						},
					},
					default: 'one',
					close: (html) => {
						if (confirmed) {
							let manCrit = html.find('[name=manCrit]')[0]?.value;

							if (manCrit == 'undefined') {
								manCrit = '1';
							}
							switch (type) {
								case 'pc':
								case 'npc':
									if (!manCrit.match(/^[1-6]?[1-6]$/gm)) {
										ui.notifications.warn(game.i18n.localize('TALESOFTHEOLDWEST.dialog.RollManCharCrit'));
										return;
									}
									break;
								default:
									break;
							}
							actor.rollCrit(actor, type, dataset, manCrit);
						}
					},
				}).render(true);
			});
		}
		switch (actor.type) {
			case 'pc':
			case 'npc':
				myRenderTemplate('systems/talesoftheoldwest/templates/dialog/roll-char-manual-crit-dialog.html');

				break;
			// case 'synthetic':
			// case 'creature':
			// 	myRenderTemplate('systems/talesoftheoldwest/templates/dialog/roll-syn-manual-crit-dialog.html');
			// 	break;
			// case 'spacecraft':
			// 	if (dataset.crbut === 'minor') {
			// 		myRenderTemplate('systems/talesoftheoldwest/templates/dialog/roll-spacecraft-minor-crit-dialog.html');
			// 	} else {
			// 		myRenderTemplate('systems/talesoftheoldwest/templates/dialog/roll-spacecraft-major-crit-dialog.html');
			// 	}

			// 	break;

			default:
				break;
		}
	}

	async diceRoll(actor, event, target) {
		event.preventDefault(); // Don't open context menu
		event.stopPropagation(); // Don't trigger other events
		if (event.detail > 1) return; // Ignore repeated clicks

		const dataset = target.dataset;
		// const targetActor = actor.getRollData();
		dataset.faithpoints = actor.system.general.faithpoints.value;
		dataset.canPush = actor.system.general.canPush;
		dataset.myActor = actor.id;
		let result = '';

		// Handle item rolls.
		if (dataset.rollType) {
			if (dataset.rollType === 'attribute' || dataset.rollType === 'ability') {
				switch (dataset.rollType) {
					case 'attribute':
					case 'ability':
						result = await rollAttrib(dataset);
						break;
					default:
						break;
				}
			} else {
				const itemId = target.dataset.itemId;
				const item = actor.items.get(itemId);
				switch (dataset.rollType) {
					case 'item':
					case 'talent':
						return item.roll(dataset);
					case 'weapon':
						result = await item.roll(dataset, item);

					default:
						break;
				}
			}
			if (result === 'cancelled') {
				return;
			}
			const html = await renderTemplate('systems/talesoftheoldwest/templates/chat/roll.hbs', result[1]);
			let chatData = {
				user: game.user.id,
				speaker: ChatMessage.getSpeaker({
					alias: actor.name,
					actor: actor.id,
				}),
				rolls: [result[0]],
				rollMode: game.settings.get('core', 'rollMode'),
				content: html,
				sound: CONFIG.sounds.dice,
			};
			if (['gmroll', 'blindroll'].includes(chatData.rollMode)) {
				chatData.whisper = ChatMessage.getWhisperRecipients('GM');
			} else if (chatData.rollMode === 'selfroll') {
				chatData.whisper = [game.user];
			}
			const msg = await ChatMessage.create(chatData);
			result[1].messageNo = msg.id;
			await msg.setFlag('talesoftheoldwest', 'results', result);

			return result;
		}
	}

	async modRoll(actor, event, target) {
		function myRenderTemplate(template) {
			let confirmed = false;
			renderTemplate(template).then((dlg) => {
				new Dialog({
					title: game.i18n.localize('TALESOFTHEOLDWEST.Item.General.roll-modifiers').toUpperCase(),
					content: dlg,
					buttons: {
						one: {
							icon: '<i class="fas fa-check"></i>',
							label: game.i18n.localize('TALESOFTHEOLDWEST.dialog.roll'),
							callback: () => (confirmed = true),
						},
						four: {
							icon: '<i class="fas fa-times"></i>',
							label: game.i18n.localize('TALESOFTHEOLDWEST.dialog.cancel'),
							callback: () => (confirmed = false),
						},
					},
					default: 'one',
					close: (html) => {
						if (confirmed) {
							let manCrit = parseInt(html.find('[name=manCrit]')[0]?.value);

							if (manCrit == 'undefined') {
								manCrit = '1';
							}
							target.dataset.mod = parseInt(target.dataset.mod) + manCrit;
							actor.diceRoll(actor, event, target);

							// actor.rollCrit(actor, type, dataset, manCrit);
						}
					},
				}).render(true);
			});
		}

		myRenderTemplate('systems/talesoftheoldwest/templates/dialog/roll-modifier.html');
	}

	async createChatMessage(message, actorID) {
		let chatData = {
			user: game.user.id,
			speaker: {
				actor: actorID,
			},
			content: new Handlebars.SafeString(message),
			other: game.users.contents.filter((u) => u.isGM).map((u) => u.id),
			sound: CONFIG.sounds.lock,
		};

		ChatMessage.applyRollMode(chatData, game.settings.get('core', 'rollMode'));
		return ChatMessage.create(chatData);
	}
}
