/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export class totowActor extends Actor {
	/** @override */
	prepareData() {
		// Prepare data for the actor. Calling the super version of this executes
		// the following, in order: data reset (to clear active effects),
		// prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
		// prepareDerivedData().
		super.prepareData();
	}

	/** @override */
	prepareBaseData() {
		// Data modifications in this step occur before processing embedded
		// documents or derived data.
	}

	/**
	 * @override
	 * Augment the actor source data with additional dynamic data that isn't
	 * handled by the actor's DataModel. Data calculated in this step should be
	 * available both inside and outside of character sheets (such as if an actor
	 * is queried and has a roll executed directly from it).
	 */
	prepareDerivedData() {
		const actorData = this;
		const flags = actorData.flags.talesoftheoldwest || {};
	}

	/**
	 *
	 * @override
	 * Augment the actor's default getRollData() method by appending the data object
	 * generated by the its DataModel's getRollData(), or null. This polymorphic
	 * approach is useful when you have actors & items that share a parent Document,
	 * but have slightly different data preparation needs.
	 */
	getRollData() {
		return { ...super.getRollData(), ...(this.system.getRollData?.() ?? null) };
	}
	// *************************************************
	// Setupthe prototype token
	// *************************************************
	async _preCreate(data, options, user) {
		await super._preCreate(data, options, user);
		let tokenProto = {
			'prototypeToken.displayName': CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,
			'prototypeToken.displayBars': CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,
			'prototypeToken.disposition': CONST.TOKEN_DISPOSITIONS.FRIENDLY,
			'prototypeToken.name': `${data.name}`,
			'prototypeToken.bar1': { attribute: 'header.health' },
			'prototypeToken.bar2': { attribute: 'None' },
			// 'prototypeToken.vision': true,
			'prototypeToken.actorLink': true,
			'prototypeToken.sight.enabled': 'true',
			'prototypeToken.sight.range': '12',
		};
		// if (game.settings.get('alienrpg', 'defaultTokenSettings')) {
		switch (data.type) {
			case 'pc':
				tokenProto['prototypeToken.bar2'] = { attribute: 'header.stress' };
				break;
			case 'npc':
				tokenProto['prototypeToken.actorLink'] = false;
				tokenProto['prototypeToken.disposition'] = CONST.TOKEN_DISPOSITIONS.HOSTILE;
				tokenProto['prototypeToken.sight.enabled'] = false;
				break;
		}
		// }

		this.updateSource(tokenProto);
		// this.updateSource(createData);
	}
}
