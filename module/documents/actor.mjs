import { rollAttrib } from '../helpers/diceroll.mjs';
import * as argpUtils from '../helpers/utils.mjs';

/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export class totowActor extends Actor {
	/** @override */
	prepareData() {
		// Prepare data for the actor. Calling the super version of this executes
		// the following, in order: data reset (to clear active effects),
		// prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
		// prepareDerivedData().
		super.prepareData();
	}

	/** @override */
	prepareBaseData() {
		// Data modifications in this step occur before processing embedded
		// documents or derived data.
	}

	/**
	 * @override
	 * Augment the actor source data with additional dynamic data that isn't
	 * handled by the actor's DataModel. Data calculated in this step should be
	 * available both inside and outside of character sheets (such as if an actor
	 * is queried and has a roll executed directly from it).
	 */
	prepareDerivedData() {
		const actorData = this;
		const systemData = actorData.system;
		const flags = actorData.flags.talesoftheoldwest || {};
	}

	/**
	 *
	 * @override
	 * Augment the actor's default getRollData() method by appending the data object
	 * generated by the its DataModel's getRollData(), or null. This polymorphic
	 * approach is useful when you have actors & items that share a parent Document,
	 * but have slightly different data preparation needs.
	 */
	getRollData() {
		let spanner = { ...super.getRollData(), ...(this.system.getRollData?.() ?? null) };
		spanner.actorType = this.type;
		return spanner;
	}
	// *************************************************
	// Setupthe prototype token
	// *************************************************
	async _preCreate(data, options, user) {
		await super._preCreate(data, options, user);
		let tokenProto = {
			'prototypeToken.displayName': CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,
			'prototypeToken.displayBars': CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,
			'prototypeToken.disposition': CONST.TOKEN_DISPOSITIONS.FRIENDLY,
			'prototypeToken.name': `${data.name}`,
			'prototypeToken.bar1': { attribute: 'header.health' },
			'prototypeToken.bar2': { attribute: 'None' },
			// 'prototypeToken.vision': true,
			'prototypeToken.actorLink': true,
			'prototypeToken.sight.enabled': 'true',
			'prototypeToken.sight.range': '12',
		};
		// if (game.settings.get('alienrpg', 'defaultTokenSettings')) {
		switch (data.type) {
			case 'pc':
				tokenProto['prototypeToken.bar2'] = { attribute: 'header.stress' };
				break;
			case 'npc':
				tokenProto['prototypeToken.actorLink'] = false;
				tokenProto['prototypeToken.disposition'] = CONST.TOKEN_DISPOSITIONS.HOSTILE;
				tokenProto['prototypeToken.sight.enabled'] = false;
				break;
		}
		// }

		this.updateSource(tokenProto);
		// this.updateSource(createData);
	}

	async addCondition(effect) {
		if (typeof effect === 'string') effect = foundry.utils.duplicate(CONFIG.TALESOFTHEOLDWEST.conditionEffects.find((e) => e.id == effect));
		if (!effect) return 'No Effect Found';
		if (!effect.id) return 'Conditions require an id field';

		let existing = await this.hasCondition(effect.id);
		if (!existing) {
			effect.label = game.i18n.localize(effect.label).replace(/(^\w{1})|(\s+\w{1})/g, (letter) => letter.toUpperCase());
			effect.name = game.i18n.localize(effect.name).replace(/(^\w{1})|(\s+\w{1})/g, (letter) => letter.toUpperCase());
			effect['statuses'] = effect.id;
			delete effect.id;
			return await this.createEmbeddedDocuments('ActiveEffect', [effect]);
		}
	}

	async removeCondition(effect) {
		if (typeof effect === 'string') effect = foundry.utils.duplicate(CONFIG.TALESOFTHEOLDWEST.conditionEffects.find((e) => e.id == effect));
		if (!effect) return 'No Effect Found';
		if (!effect.id) return 'Conditions require an id field';
		let existing = await this.hasCondition(effect.id);
		if (existing) {
			return await this.deleteEmbeddedDocuments('ActiveEffect', [existing._id]);
		}
	}
	async hasCondition(conditionKey) {
		let existing = '';
		existing = this.effects.find((effect) => effect.statuses.has(conditionKey));
		return existing;
	}

	async rollCrit(actor, type, dataset, manCrit) {
		let cFatal = false;
		let fatal = [];
		let rollFatal = '';
		let newFatalTime = '';
		let atable = '';
		let testArray = '';
		let rollheal = '';
		let newHealTime = '';
		let htmlData = '';
		let resultImage = '';
		let diceRoll = '';
		let update = {};
		let noMods = '';

		switch (type) {
			case 'pc':
				// case 'npc':
				atable = game.tables.getName(game.i18n.localize('ALIENRPG.CriticalInjuries')) || game.tables.getName('Critical Injuries');
				if (atable === null || atable === undefined) {
					ui.notifications.warn(game.i18n.localize('ALIENRPG.NoCharCrit'));
					return;
				}

				break;
			default:
				return;
		}

		if (!manCrit) {
			diceRoll = await atable.draw({ displayChat: false });
		} else {
			const formula = manCrit;
			const roll = await new Roll(formula).evaluate();
			diceRoll = await atable.draw({ roll: roll, displayChat: false });
		}
		const messG = diceRoll.results[0].text;
		switch (type) {
			case 'pc':
			case 'npc':
				{
					resultImage = diceRoll.results[0].img;
					// Split out the components
					testArray = messG
						.replace(/(<p>)|(<strong>)|(<\/strong>)/gi, '')
						.replace(/(<\/p>)/gi, ': ')
						.split(/[:] /gi);

					// Process Fatial
					fatal = testArray[5].split(/[\/] /gi);
					if (fatal[0] != game.i18n.localize('TALESOFTHEOLDWEST.General.no')) {
						if (fatal[1] === game.i18n.localize('TALESOFTHEOLDWEST.Criticals.instant')) {
							cFatal = true;
							fatal[0] =
								'<strong style="color: red;">' + fatal[0].toUpperCase() + '</strong><br>' + game.i18n.localize('TALESOFTHEOLDWEST.Criticals.endOfTheTrail');
							testArray[11] = '<strong style="color: red;">' + testArray[11] + '</strong>';
						} else {
							rollFatal = fatal[1].match(/^\[\[([0-9]d[0-9]+)]/)[1];
							newFatalTime = fatal[1].match(/^\[\[([0-9]d[0-9]+)\]\] ?(.*)/)[2];
							fatal[1] = (await new Roll(`${rollFatal}`).evaluate()).result + ' ' + newFatalTime;
							fatal[0] = fatal[0].toUpperCase();

							switch (testArray[5]) {
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' ':
									{
										cFatal = true;
										fatal[0] = '<strong style="color: red;">' + game.i18n.localize('TALESOFTHEOLDWEST.General.yes').toUpperCase() + '</strong>';
									}
									break;
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' −1 / [[1d6]] Rounds':
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' −1 / [[2d6]] Rounds':
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' −1 / [[1d6]] Turns':
									{
										cFatal = true;
										fatal[0] =
											'<strong style="color: red;">' +
											game.i18n.localize('TALESOFTHEOLDWEST.General.yes').toUpperCase() +
											'</strong><br>' +
											game.i18n.localize('TALESOFTHEOLDWEST.Criticals.rollResilience') +
											fatal[1] +
											'<br> -1 to <strong>' +
											game.i18n.localize('TALESOFTHEOLDWEST.Ability.Doctorin.long') +
											'</strong> roll.';
									}
									break;
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' / [[1d6]] Turns':
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' / [[2d6]] Turns':
								case game.i18n.localize('TALESOFTHEOLDWEST.General.yes') + ' / [[1d6]] Days':
									{
										cFatal = true;
										fatal[0] =
											'<strong style="color: red;">' +
											game.i18n.localize('TALESOFTHEOLDWEST.General.yes').toUpperCase() +
											'</strong><br>' +
											game.i18n.localize('TALESOFTHEOLDWEST.Criticals.rollResilience') +
											fatal[1];
									}
									break;
								default:
									cFatal = false;
									break;
							}
						}
					} else {
						fatal[0] = game.i18n.localize('TALESOFTHEOLDWEST.General.no');
					}

					// Process Healing Time
					if ((testArray[7].length > 0) & (fatal[1] != 'Instant')) {
						rollheal = testArray[7].match(/^\[\[([0-9]d[0-9]+)]/)[1];
						newHealTime = testArray[7].match(/^\[\[([0-9]d[0-9]+)\]\] ?(.*)/)[2];
						testArray[7] = (await new Roll(`${rollheal}`).evaluate()).result + ' ' + newHealTime;
					} else {
						testArray[7] = game.i18n.localize('TALESOFTHEOLDWEST.ItemModifierSelect.none');
					}

					// Setup Modifiers
					switch (diceRoll.roll._total) {
						case 11:
						case 14:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Move.listName'),
								value: '-1',
								state: 'Active',
							};
							update[`system.itemModifiers.[1]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Fightin.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 12:
						case 21:
						case 23:
						case 41:
						case 51:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Move.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 22:
						case 44:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Resilience.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 31:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Shootin.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 32:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Shootin.listName'),
								value: '-1',
								state: 'Active',
							};
							update[`system.itemModifiers.[1]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Fightin.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 52:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Move.listName'),
								value: '-2',
								state: 'Active',
							};
							break;
						case 61:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Performin.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 62:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Labor.listName'),
								value: '-1',
								state: 'Active',
							};
							break;
						case 63:
							update[`system.itemModifiers.[0]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Shootin.listName'),
								value: '-2',
								state: 'Active',
							};
							update[`system.itemModifiers.[1]`] = {
								name: game.i18n.localize('TALESOFTHEOLDWEST.Ability.Hawkeye.listName'),
								value: '-2',
								state: 'Active',
							};
							break;
						default:
							noMods = true;
							break;
					}

					//
					// Now create the item on the sheet
					//

					let rollData = {
						type: 'crit',
						img: resultImage,
						name: `#${diceRoll.roll._total} ${testArray[1]} - ${testArray[3]}`,
						'system.location': testArray[1].toLowerCase().replace(/\s/g, ''),
						'system.injury': testArray[3],
						'system.healingtime': testArray[7],
						'system.fatal': cFatal,
						'system.fatalmessage': fatal[0].replace(/(YES)\s/g, ''),
						'system.imediateeffect': testArray[9],
						'system.longtermeffect': testArray[11],
					};

					const theItem = await this.createEmbeddedDocuments('Item', [rollData]);

					//
					// Now add the Modifiers if there are any
					//
					if (!noMods) {
						await theItem[0].update(update);
					}

					//)
					// Prepare the data for the chat message
					//

					htmlData = {
						actorname: actor.name,
						img: resultImage,
						name: `#${diceRoll.roll._total} ${testArray[1]}`,
						injury: testArray[3],
						fatal: fatal[0],
						healingtime: testArray[7],
						imediateeffect: testArray[9],
						longtermeffect: testArray[11],
						manCrit: manCrit,
					};
				}
				break;
		}

		// Now push the correct chat message

		const html = await renderTemplate(`systems/talesoftheoldwest/templates/chat/crit-roll-${actor.type}.hbs`, htmlData);

		let chatData = {
			user: game.user.id,
			speaker: {
				actor: actor.id,
			},
			content: html,
			other: game.users.contents.filter((u) => u.isGM).map((u) => u.id),
			sound: CONFIG.sounds.dice,
		};

		// Apply the Active Effect

		switch (type) {
			case 'pc':
				// case 'npc':
				await this.addCondition('criticalinj');
				break;
			// case 'creature':criticalinj
			// 	console.log("it's a Creature Crit");
			// 	break;

			default:
				break;
		}

		ChatMessage.applyRollMode(chatData, game.settings.get('core', 'rollMode'));
		return ChatMessage.create(chatData);
	}

	async rollCritMan(actor, type, dataset) {
		const content = await renderTemplate('systems/talesoftheoldwest/templates/dialog/roll-char-manual-crit-dialog.html', actor, type, dataset);
		const response = await foundry.applications.api.DialogV2.wait({
			window: { title: 'Proceed' },
			content,
			rejectClose: false,
			buttons: [
				{
					label: 'TALESOFTHEOLDWEST.dialog.roll',
					callback: (event, button) => new FormDataExtended(button.form).object,
				},
				{
					label: 'TALESOFTHEOLDWEST.dialog.cancel',
					action: 'cancel',
				},
			],
		});
		if (!response || response === 'cancel') return 'cancelled';
		if (!response.manCrit.match(/^[1-6]?[1-6]$/gm)) {
			ui.notifications.warn(game.i18n.localize('TALESOFTHEOLDWEST.dialog.RollManCharCrit'));
			return;
		}
		await actor.rollCrit(actor, type, dataset, response.manCrit);
	}

	async diceRoll(actor, event, target) {
		let config = CONFIG.TALESOFTHEOLDWEST;

		event.preventDefault(); // Don't open context menu
		event.stopPropagation(); // Don't trigger other events
		if (event.detail > 1) return; // Ignore repeated clicks
		const rollData = this.getRollData();
		const dataset = target.dataset;
		dataset.conditional = '';
		dataset.talent = '';

		// const targetActor = actor.getRollData();
		if (actor.type === 'pc') {
			dataset.faithpoints = actor.system.general.faithpoints.value;
			dataset.canPush = actor.system.general.canPush;
		} else {
			dataset.faithpoints = 0;
			dataset.canPush = false;
		}

		dataset.myActor = actor.id;
		let result = '';

		// Handle item rolls.
		if (dataset.rollType) {
			if (dataset.rollType === 'attribute' || dataset.rollType === 'ability') {
				switch (dataset.rollType) {
					case 'attribute':
						result = await processConditionals('Attributes', dataset, rollData);
						break;
					case 'ability':
						if (dataset.label === game.i18n.localize('TALESOFTHEOLDWEST.Ability.Animalhandlin.long')) {
							if (actor.system.horse.name) {
								const content = await renderTemplate('systems/talesoftheoldwest/templates/dialog/riding-my-horse.hbs', actor, event, target);
								const response = await foundry.applications.api.DialogV2.confirm({
									window: { title: 'Proceed' },
									content,
									modal: true,
								});
								if (response === true) {
									dataset.mod = Number(dataset.mod) + Number(actor.system.horse.general.ridingmodifier.value);
								}
							}
						}
						result = await processConditionals('Abilities', dataset, rollData);
						break;
					default:
						break;
				}
			} else {
				const itemId = target.dataset.itemId;
				const item = actor.items.get(itemId);
				switch (dataset.rollType) {
					case 'item':
						// case 'talent':
						return item.roll(dataset);
					case 'weapon':
						result = await item.roll(dataset, item);
					default:
						break;
				}
			}
			if (result === 'cancelled') {
				return;
			} else {
				sendToChat(actor, event, target, result);
			}

			async function processConditionals(rollType, dataset, rollData) {
				await argpUtils.prepModOutput(rollType, rollData, dataset);
				if (dataset.conditional) {
					const content = await renderTemplate('systems/talesoftheoldwest/templates/dialog/conditional-modifiers.html', {
						config,
						dataset,
					});
					const data = await foundry.applications.api.DialogV2.wait({
						window: { title: 'Roll Modifiers' },
						position: { width: 350 },
						// classes: ["my-special-class"],
						content,
						rejectClose: false,
						buttons: [
							{
								label: 'TALESOFTHEOLDWEST.dialog.roll',
								callback: (event, button) => new FormDataExtended(button.form).object,
							},
							{
								label: 'TALESOFTHEOLDWEST.dialog.cancel',
								action: 'cancel',
							},
						],
					});

					if (!data || data === 'cancel') return 'cancelled';

					Object.keys(data).forEach((key) => {
						if (key.startsWith('floop')) {
							data.modifier = parseInt(data.modifier || 0) + parseInt(data[key] || 0);
						}
					});

					dataset.mod = parseInt(dataset.mod || 0) + Number(data.modifier);
				}

				result = await rollAttrib(dataset, rollData, actor);
				return result;
			}

			async function sendToChat(actor, event, target, result) {
				{
					const html = await renderTemplate('systems/talesoftheoldwest/templates/chat/roll.hbs', result[1]);
					let chatData = {
						user: game.user.id,
						speaker: ChatMessage.getSpeaker({
							alias: actor.name,
							actor: actor.id,
						}),
						rolls: [result[0]],
						rollMode: game.settings.get('core', 'rollMode'),
						content: html,
						sound: CONFIG.sounds.dice,
					};
					if (['gmroll', 'blindroll'].includes(chatData.rollMode)) {
						chatData.whisper = ChatMessage.getWhisperRecipients('GM');
					} else if (chatData.rollMode === 'selfroll') {
						chatData.whisper = [game.user];
					}
					const msg = await ChatMessage.create(chatData);
					result[1].messageNo = msg.id;
					await msg.setFlag('talesoftheoldwest', 'results', result);

					return result;
				}
			}
		}
		this.render();
	}

	async modRoll(actor, event, target) {
		const content = await renderTemplate('systems/talesoftheoldwest/templates/dialog/roll-modifier.html', actor, event, target);
		const response = await foundry.applications.api.DialogV2.wait({
			window: { title: 'Roll Modifiers' },
			content,
			rejectClose: false,
			buttons: [
				{
					label: 'TALESOFTHEOLDWEST.dialog.roll',
					callback: (event, button) => new FormDataExtended(button.form).object,
				},
				{
					label: 'TALESOFTHEOLDWEST.dialog.cancel',
					action: 'cancel',
				},
			],
		});
		if (!response || response === 'cancel') return 'cancelled';
		target.dataset.mod = Number(target.dataset.mod) + Number(response.manMod);
		await actor.diceRoll(actor, event, target);
	}

	async createChatMessage(message, actorID) {
		let chatData = {
			user: game.user.id,
			speaker: {
				actor: actorID,
			},
			content: new Handlebars.SafeString(message),
			other: game.users.contents.filter((u) => u.isGM).map((u) => u.id),
			sound: CONFIG.sounds.lock,
		};

		ChatMessage.applyRollMode(chatData, game.settings.get('core', 'rollMode'));
		return ChatMessage.create(chatData);
	}

	/* ------------------------------------------- */
	/*  linked actors Management                   */
	/* ------------------------------------------- */

	/**
	 * @param {string}  compId              The id of the added actor
	 * @returns {details}
	 */
	async addCompadres(compId) {
		if (this.type !== 'pc') return;

		const system = this.system;
		const details = {
			id: compId,
		};
		// Removes duplicates.
		if (system.compadres.details.some((o) => o.id === compId)) this.removeCompadres(compId);
		// Adds the new occupant.
		system.compadres.details.push(details);
		await this.update({ 'system.compadres.details': system.compadres.details });

		await this.update({ 'system.compadres.compadresQty': system.compadres.details.length });

		return details;
	}

	/* ------------------------------------------- */

	/**
	 * @param {string} compId The id of the occupant to remove
	 * @return {Compadres[]}
	 */
	removeCompadres(compId) {
		if (this.type !== 'pc') return;
		const compadres = this.system.compadres;
		compadres.details = compadres.details.filter((o) => o.id !== compId);
		return compadres.details;
	}

	/* ------------------------------------------- */

	/**
	 * @param {string} compId The id of the occupant to find
	 * @returns {VehicleOccupant|undefined}
	 */
	getCompadres(compId) {
		if (this.type !== 'pc') return;
		return this.system.compadres.details.find((o) => o.id === compId);
	}

	/* ------------------------------------------- */
	/**
	 * @param {string}  compId              The id of the added actor
	 * @returns {details}
	 */
	async addRemuda(compId) {
		if (this.type !== 'pc') return;

		const system = this.system;
		const details = {
			id: compId,
		};
		// Removes duplicates.
		if (system.remuda.details.some((o) => o.id === compId)) this.removeRemuda(compId);
		// Adds the new occupant.
		system.remuda.details.push(details);
		await this.update({ 'system.remuda.details': system.remuda.details });

		await this.update({ 'system.remuda.remudaQty': system.remuda.details.length });

		return details;
	}

	/* ------------------------------------------- */

	/**
	 * @param {string} compId The id of the occupant to remove
	 * @return {Remuda[]}
	 */
	removeRemuda(compId) {
		if (this.type !== 'pc') return;
		const remuda = this.system.remuda;
		remuda.details = remuda.details.filter((o) => o.id !== compId);
		return remuda.details;
	}

	/* ------------------------------------------- */

	/**
	 * @param {string} compId The id of the occupant to find
	 * @returns {VehicleOccupant|undefined}
	 */
	getRemuda(compId) {
		if (this.type !== 'pc') return;
		return this.system.remuda.details.find((o) => o.id === compId);
	}

	/**
	 * Gets a collection of crewed actors.
	 * @returns {Collection<string, Actor>} [id, actor]
	 */
	getCrew() {
		if (this.type !== 'pc') return undefined;
		const c = new foundry.utils.Collection();
		for (const o of this.system.compadres.details) {
			c.set(o.id, game.actors.get(o.id));
		}
		return c;
	}
}
